{"ast":null,"code":"import has from 'lodash/has'; // @ts-expect-error\n\nimport toposort from 'toposort';\nimport { split } from 'property-expr';\nimport Ref from '../Reference';\nimport isSchema from './isSchema';\nexport default function sortFields(fields) {\n  let excludedEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let edges = [];\n  let nodes = new Set();\n  let excludes = new Set(excludedEdges.map(_ref => {\n    let [a, b] = _ref;\n    return `${a}-${b}`;\n  }));\n  function addNode(depPath, key) {\n    let node = split(depPath)[0];\n    nodes.add(node);\n    if (!excludes.has(`${key}-${node}`)) edges.push([key, node]);\n  }\n  for (const key in fields) if (has(fields, key)) {\n    let value = fields[key];\n    nodes.add(key);\n    if (Ref.isRef(value) && value.isSibling) addNode(value.path, key);else if (isSchema(value) && 'deps' in value) value.deps.forEach(path => addNode(path, key));\n  }\n  return toposort.array(Array.from(nodes), edges).reverse();\n}","map":{"version":3,"names":["has","toposort","split","Ref","isSchema","sortFields","fields","excludedEdges","edges","nodes","Set","excludes","map","a","b","addNode","depPath","key","node","add","push","value","isRef","isSibling","path","deps","forEach","array","Array","from","reverse"],"sources":["/home/matti/Desktop/JEToP/readytoReact_live_coding/node_modules/yup/es/util/sortFields.js"],"sourcesContent":["import has from 'lodash/has'; // @ts-expect-error\n\nimport toposort from 'toposort';\nimport { split } from 'property-expr';\nimport Ref from '../Reference';\nimport isSchema from './isSchema';\nexport default function sortFields(fields, excludedEdges = []) {\n  let edges = [];\n  let nodes = new Set();\n  let excludes = new Set(excludedEdges.map(([a, b]) => `${a}-${b}`));\n\n  function addNode(depPath, key) {\n    let node = split(depPath)[0];\n    nodes.add(node);\n    if (!excludes.has(`${key}-${node}`)) edges.push([key, node]);\n  }\n\n  for (const key in fields) if (has(fields, key)) {\n    let value = fields[key];\n    nodes.add(key);\n    if (Ref.isRef(value) && value.isSibling) addNode(value.path, key);else if (isSchema(value) && 'deps' in value) value.deps.forEach(path => addNode(path, key));\n  }\n\n  return toposort.array(Array.from(nodes), edges).reverse();\n}"],"mappings":"AAAA,OAAOA,GAAG,MAAM,YAAY,CAAC,CAAC;;AAE9B,OAAOC,QAAQ,MAAM,UAAU;AAC/B,SAASC,KAAK,QAAQ,eAAe;AACrC,OAAOC,GAAG,MAAM,cAAc;AAC9B,OAAOC,QAAQ,MAAM,YAAY;AACjC,eAAe,SAASC,UAAU,CAACC,MAAM,EAAsB;EAAA,IAApBC,aAAa,uEAAG,EAAE;EAC3D,IAAIC,KAAK,GAAG,EAAE;EACd,IAAIC,KAAK,GAAG,IAAIC,GAAG,EAAE;EACrB,IAAIC,QAAQ,GAAG,IAAID,GAAG,CAACH,aAAa,CAACK,GAAG,CAAC;IAAA,IAAC,CAACC,CAAC,EAAEC,CAAC,CAAC;IAAA,OAAM,GAAED,CAAE,IAAGC,CAAE,EAAC;EAAA,EAAC,CAAC;EAElE,SAASC,OAAO,CAACC,OAAO,EAAEC,GAAG,EAAE;IAC7B,IAAIC,IAAI,GAAGhB,KAAK,CAACc,OAAO,CAAC,CAAC,CAAC,CAAC;IAC5BP,KAAK,CAACU,GAAG,CAACD,IAAI,CAAC;IACf,IAAI,CAACP,QAAQ,CAACX,GAAG,CAAE,GAAEiB,GAAI,IAAGC,IAAK,EAAC,CAAC,EAAEV,KAAK,CAACY,IAAI,CAAC,CAACH,GAAG,EAAEC,IAAI,CAAC,CAAC;EAC9D;EAEA,KAAK,MAAMD,GAAG,IAAIX,MAAM,EAAE,IAAIN,GAAG,CAACM,MAAM,EAAEW,GAAG,CAAC,EAAE;IAC9C,IAAII,KAAK,GAAGf,MAAM,CAACW,GAAG,CAAC;IACvBR,KAAK,CAACU,GAAG,CAACF,GAAG,CAAC;IACd,IAAId,GAAG,CAACmB,KAAK,CAACD,KAAK,CAAC,IAAIA,KAAK,CAACE,SAAS,EAAER,OAAO,CAACM,KAAK,CAACG,IAAI,EAAEP,GAAG,CAAC,CAAC,KAAK,IAAIb,QAAQ,CAACiB,KAAK,CAAC,IAAI,MAAM,IAAIA,KAAK,EAAEA,KAAK,CAACI,IAAI,CAACC,OAAO,CAACF,IAAI,IAAIT,OAAO,CAACS,IAAI,EAAEP,GAAG,CAAC,CAAC;EAC/J;EAEA,OAAOhB,QAAQ,CAAC0B,KAAK,CAACC,KAAK,CAACC,IAAI,CAACpB,KAAK,CAAC,EAAED,KAAK,CAAC,CAACsB,OAAO,EAAE;AAC3D"},"metadata":{},"sourceType":"module","externalDependencies":[]}